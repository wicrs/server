use crate::{api, channel, hub::Hub, Error, Result, ID};
use actix::prelude::*;
use std::collections::{HashMap, HashSet};

#[derive(Message, Clone)]
#[rtype(result = "Result<()>")]
pub struct ClientServerMessage {
    /// Client address to send the response to.
    client_addr: Recipient<ServerClientMessage>,
    /// ID of the message, server will use this to send a response. Should be generated by the client.
    message_id: u128,
    /// Client's message.
    command: ClientCommand,
}

#[derive(Clone)]
pub enum ClientCommand {
    Connect(ID, Recipient<ServerClientMessage>),
    Disconnect(ID, Recipient<ServerClientMessage>),
    Subscribe(ID, ID, ID),
    Unsubscribe(ID, ID, ID),
    StartTyping(ID, ID, ID),
    StopTyping(ID, ID, ID),
    SendMessage(ID, ID, ID, String),
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub struct ServerClientMessage {
    /// ID of the message the server is responding to.
    responding_to: u128,
    /// Server's response.
    command: ServerCommand,
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub enum ServerCommand {
    NewMessage(ID, ID, channel::Message),
    TypingStart(ID, ID, ID),
    TypingStop(ID, ID, ID),
    Error(Error),
    Success,
}

pub struct Server {
    subscribed: HashMap<(ID, ID), HashSet<ID>>, // HashMap<(HubID, ChannelID), Vec<UserID>>
    sessions: HashMap<ID, HashSet<Recipient<ServerClientMessage>>>, // HashMap<UserID, UserSession>
    typing: HashSet<ID>,
}

impl Server {
    pub fn new() -> Self {
        Self {
            subscribed: HashMap::new(),
            sessions: HashMap::new(),
            typing: HashSet::new(),
        }
    }

    async fn send_message(
        subscribed: HashMap<(ID, ID), HashSet<ID>>,
        sessions: HashMap<ID, HashSet<Recipient<ServerClientMessage>>>,
        message: ServerCommand,
        hub_id: ID,
        channel_id: ID,
    ) {
        if let Some(subscribed) = subscribed.get(&(hub_id, channel_id)) {
            for user_id in subscribed {
                if let Some(sessions) = sessions.get(user_id) {
                    for connection in sessions {
                        let _ = connection.do_send(message.clone());
                    }
                }
            }
        }
    }
}

impl Actor for Server {
    type Context = Context<Self>;
}

impl Handler<ClientServerMessage> for Server {
    type Result = Result<()>;

    fn handle(&mut self, msg: ClientServerMessage, ctx: &mut Self::Context) -> Self::Result {
        match msg.command {
            ClientCommand::Connect(user_id, addr) => {
                self.sessions
                    .entry(user_id)
                    .or_insert_with(|| HashSet::new())
                    .insert(addr);
            }
            ClientCommand::Disconnect(user_id, addr) => {
                if let Some(set) = self.sessions.get_mut(&user_id) {
                    set.remove(&addr);
                }
            }
            ClientCommand::Subscribe(user_id, hub_id, channel_id) => {}
            ClientCommand::Unsubscribe(user_id, hub_id, channel_id) => {
                if let Some(entry) = self.subscribed.get_mut(&(hub_id, channel_id)) {
                    entry.remove(&user_id);
                }
            }
            ClientCommand::StartTyping(user_id, hub_id, channel_id) => {
                if self.typing.contains(&user_id) {
                    return Err(Error::AlreadyTyping);
                } else {
                    let subscribed = self.subscribed.clone();
                    let sessions = self.sessions.clone();
                    async move {
                        let result = if let Err(err) = {
                            let result = Hub::load(&hub_id)
                                .await
                                .and_then(|hub| hub.get_channel(&user_id, &channel_id))
                                .and_then(|_| {
                                    Ok(Self::send_message(
                                        subscribed,
                                        sessions,
                                        ServerCommand::TypingStart(
                                            hub_id.clone(),
                                            channel_id.clone(),
                                            user_id.clone(),
                                        ),
                                        hub_id,
                                        channel_id,
                                    ))
                                });
                            if let Ok(fut) = result {
                                fut.await;
                                Ok(())
                            } else {
                                Err(result.err().unwrap())
                            }
                        } {
                            ServerCommand::Error(err)
                        } else {
                            ServerCommand::Success
                        };
                        msg.client_addr
                            .send(ServerClientMessage {
                                responding_to: msg.message_id,
                                command: result,
                            })
                            .await;
                    }
                    .into_actor(self)
                    .spawn(ctx);
                }
            }
            ClientCommand::StopTyping(user_id, hub_id, channel_id) => {}
            ClientCommand::SendMessage(user_id, hub_id, channel_id, message) => {}
        }
        Ok(())
    }
}

impl Handler<StartTyping> for Server {
    type Result = Result<()>;

    fn handle(&mut self, msg: StartTyping, ctx: &mut Self::Context) -> Self::Result {}
}

impl Handler<StopTyping> for Server {
    type Result = Result<()>;

    fn handle(&mut self, msg: StopTyping, _: &mut Self::Context) -> Self::Result {
        if self.typing.remove(&msg.user_id) {
            futures::executor::block_on(Self::send_message(
                self.subscribed.clone(),
                self.sessions.clone(),
                ServerClientMessage::TypingStop(
                    msg.hub_id.clone(),
                    msg.channel_id.clone(),
                    msg.user_id.clone(),
                ),
                msg.hub_id,
                msg.channel_id,
            ));
            Ok(())
        } else {
            Err(Error::NotTyping)
        }
    }
}

impl Handler<Connect> for Server {
    type Result = ();

    fn handle(&mut self, msg: Connect, _: &mut Self::Context) -> Self::Result {
        self.sessions
            .entry(msg.user_id)
            .or_insert_with(|| HashSet::new())
            .insert(msg.addr);
    }
}

impl Handler<Disconnect> for Server {
    type Result = ();

    fn handle(&mut self, msg: Disconnect, _: &mut Self::Context) -> Self::Result {
        if let Some(set) = self.sessions.get_mut(&msg.user_id) {
            set.remove(&msg.addr);
        }
    }
}

impl Handler<Subscribe> for Server {
    type Result = Result<()>;

    fn handle(&mut self, msg: Subscribe, _: &mut Self::Context) -> Self::Result {
        let Subscribe {
            user_id,
            hub_id,
            channel_id,
        } = msg.clone();
        let test: Self::Result = futures::executor::block_on(async move {
            let hub = Hub::load(&hub_id).await?;
            hub.get_channel(&user_id, &channel_id)?;
            Ok(())
        });
        test?;
        self.subscribed
            .entry((msg.hub_id, msg.channel_id))
            .or_insert_with(HashSet::new)
            .insert(msg.user_id);
        Ok(())
    }
}

impl Handler<Unsubscribe> for Server {
    type Result = ();

    fn handle(&mut self, msg: Unsubscribe, _: &mut Self::Context) -> Self::Result {
        if let Some(entry) = self.subscribed.get_mut(&(msg.hub_id, msg.channel_id)) {
            entry.remove(&msg.user_id);
        }
    }
}

impl Handler<SendMessage> for Server {
    type Result = Result<ID>;

    fn handle(&mut self, msg: SendMessage, _: &mut Self::Context) -> Self::Result {
        futures::executor::block_on(async {
            let message =
                api::send_message(&msg.user_id, &msg.hub_id, &msg.channel_id, msg.message).await?;
            let id = message.id.clone();
            Self::send_message(
                self.subscribed.clone(),
                self.sessions.clone(),
                ServerClientMessage::NewMessage(msg.hub_id, msg.channel_id, message),
                msg.hub_id,
                msg.channel_id,
            )
            .await;
            Ok(id)
        })
    }
}

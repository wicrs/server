use crate::{api, channel, hub::Hub, Error, ID};
use actix::prelude::*;
use parse_display::{Display, FromStr};
use std::{
    collections::{HashMap, HashSet},
    task::{Poll, Waker},
};

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub struct ClientServerMessage {
    /// Client address to send the response to.
    pub client_addr: Option<Recipient<ServerResponse>>,
    /// ID of the message, server will use this to send a response. Should be generated by the client.
    pub message_id: u128,
    /// Client's message.
    pub command: ClientCommand,
}

impl From<ClientCommand> for ClientServerMessage {
    fn from(cmd: ClientCommand) -> Self {
        Self {
            client_addr: None,
            message_id: 0,
            command: cmd,
        }
    }
}

#[derive(Clone)]
pub enum ClientCommand {
    Connect(ID, Recipient<ServerMessage>),
    Disconnect(ID, Recipient<ServerMessage>),
    Subscribe(ID, ID, ID),
    Unsubscribe(ID, ID, ID),
    StartTyping(ID, ID, ID),
    StopTyping(ID, ID, ID),
    SendMessage(ID, ID, ID, String),
}

#[derive(Message, Clone)]
#[rtype(result = "Response")]
pub struct GetResponse;
pub struct ResponseReceiver {
    response: Option<Response>,
    waker: Option<Waker>,
}
impl ResponseReceiver {
    pub fn new() -> Self {
        Self {
            response: None,
            waker: None,
        }
    }
}
impl Actor for ResponseReceiver {
    type Context = Context<Self>;
}
impl Handler<ServerResponse> for ResponseReceiver {
    type Result = ();

    fn handle(&mut self, msg: ServerResponse, _: &mut Self::Context) -> Self::Result {
        self.response = Some(msg.message);
        println!("response populated");
        if let Some(waker) = &self.waker {
            waker.wake_by_ref();
        }
    }
}
impl Handler<GetResponse> for ResponseReceiver {
    type Result = Response;

    fn handle(&mut self, _: GetResponse, _: &mut Self::Context) -> Self::Result {
        println!("response requested");
        futures::executor::block_on(self)
    }
}
impl Future for ResponseReceiver {
    type Output = Response;

    fn poll(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        println!("receiver polled");
        if let Some(response) = self.response.clone() {
            Poll::Ready(response)
        } else {
            self.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub struct ServerResponse {
    /// ID of the message the server is responding to.
    pub responding_to: u128,
    /// Server's response.
    pub message: Response,
}

#[derive(MessageResponse, Clone, Display, FromStr)]
#[display(style = "SNAKE_CASE")]
pub enum Response {
    #[display("{}({0})")]
    Error(Error),
    Success,
    #[display("{}({0})")]
    Id(ID),
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub enum ServerMessage {
    NewMessage(ID, ID, channel::Message),
    TypingStart(ID, ID, ID),
    TypingStop(ID, ID, ID),
}

pub struct Server {
    subscribed: HashMap<(ID, ID), HashSet<ID>>, // HashMap<(HubID, ChannelID), Vec<UserID>>
    sessions: HashMap<ID, HashSet<Recipient<ServerMessage>>>, // HashMap<UserID, UserSession>
}

impl Server {
    pub fn new() -> Self {
        Self {
            subscribed: HashMap::new(),
            sessions: HashMap::new(),
        }
    }

    async fn send_message(
        subscribed: HashMap<(ID, ID), HashSet<ID>>,
        sessions: HashMap<ID, HashSet<Recipient<ServerMessage>>>,
        message: ServerMessage,
        hub_id: ID,
        channel_id: ID,
    ) {
        if let Some(subscribed) = subscribed.get(&(hub_id, channel_id)) {
            for user_id in subscribed {
                if let Some(sessions) = sessions.get(user_id) {
                    for connection in sessions {
                        let _ = connection.do_send(message.clone());
                    }
                }
            }
        }
    }
}

impl Actor for Server {
    type Context = Context<Self>;
}

impl Handler<ClientServerMessage> for Server {
    type Result = ();

    fn handle(&mut self, msg: ClientServerMessage, ctx: &mut Self::Context) -> Self::Result {
        match msg.command.clone() {
            ClientCommand::Connect(user_id, addr) => {
                self.sessions
                    .entry(user_id)
                    .or_insert_with(|| HashSet::new())
                    .insert(addr);
            }
            ClientCommand::Disconnect(user_id, addr) => {
                if let Some(set) = self.sessions.get_mut(&user_id) {
                    set.remove(&addr);
                }
            }
            ClientCommand::Subscribe(user_id, hub_id, channel_id) => {
                let subscribed = self.subscribed.clone();
                let sessions = self.sessions.clone();
                async move {
                    let result = if let Err(err) = {
                        let result = Hub::load(&hub_id)
                            .await
                            .and_then(|hub| {
                                if let Ok(member) = hub.get_member(&user_id) {
                                    Ok((hub, member))
                                } else {
                                    Err(Error::MemberNotFound)
                                }
                            })
                            .and_then(|(hub, user)| {
                                if user.has_channel_permission(
                                    &channel_id,
                                    &crate::permission::ChannelPermission::SendMessage,
                                    &hub,
                                ) {
                                    Ok(Self::send_message(
                                        subscribed,
                                        sessions,
                                        ServerMessage::TypingStart(hub_id, channel_id, user_id),
                                        hub_id,
                                        channel_id,
                                    ))
                                } else {
                                    Err(Error::MissingChannelPermission(
                                        crate::permission::ChannelPermission::SendMessage,
                                    ))
                                }
                            });
                        if let Ok(fut) = result {
                            fut.await;
                            Ok(())
                        } else {
                            Err(result.err().unwrap())
                        }
                    } {
                        Response::Error(err)
                    } else {
                        Response::Success
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: result,
                            })
                            .await;
                    }
                }
                .into_actor(self)
                .spawn(ctx);
            }
            ClientCommand::Unsubscribe(user_id, hub_id, channel_id) => {
                if let Some(entry) = self.subscribed.get_mut(&(hub_id, channel_id)) {
                    entry.remove(&user_id);
                }
            }
            ClientCommand::StartTyping(user_id, hub_id, channel_id) => {
                let subscribed = self.subscribed.clone();
                let sessions = self.sessions.clone();
                async move {
                    let result = if let Err(err) = {
                        let result = Hub::load(&hub_id)
                            .await
                            .and_then(|hub| hub.get_channel(&user_id, &channel_id).map(|_| ()))
                            .and_then(|_| {
                                Ok(Self::send_message(
                                    subscribed,
                                    sessions,
                                    ServerMessage::TypingStart(hub_id, channel_id, user_id),
                                    hub_id,
                                    channel_id,
                                ))
                            });
                        if let Ok(fut) = result {
                            fut.await;
                            Ok(())
                        } else {
                            Err(result.err().unwrap())
                        }
                    } {
                        Response::Error(err)
                    } else {
                        Response::Success
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: result,
                            })
                            .await;
                    }
                }
                .into_actor(self)
                .spawn(ctx);
            }
            ClientCommand::StopTyping(user_id, hub_id, channel_id) => {
                let subscribed = self.subscribed.clone();
                let sessions = self.sessions.clone();
                Self::send_message(
                    subscribed,
                    sessions,
                    ServerMessage::TypingStop(hub_id, channel_id, user_id),
                    hub_id,
                    channel_id,
                )
                .into_actor(self)
                .spawn(ctx);
            }
            ClientCommand::SendMessage(user_id, hub_id, channel_id, message) => {
                let subscribed = self.subscribed.clone();
                let sessions = self.sessions.clone();
                async move {
                    let res = {
                        let send = api::send_message(&user_id, &hub_id, &channel_id, message).await;
                        if let Ok(message) = send {
                            let id = message.id.clone();
                            Self::send_message(
                                subscribed,
                                sessions,
                                ServerMessage::NewMessage(hub_id, channel_id, message),
                                hub_id,
                                channel_id,
                            )
                            .await;
                            Response::Id(id)
                        } else {
                            Response::Error(send.err().unwrap())
                        }
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: res,
                            })
                            .await;
                    }
                }
                .into_actor(self)
                .spawn(ctx);
            }
        }
    }
}

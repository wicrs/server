use crate::{api, channel, error::DataError, hub::Hub, Error, Result, ID};
use actix::prelude::*;
use futures::lock::Mutex;
use parse_display::{Display, FromStr};
use std::{
    collections::{HashMap, HashSet},
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::Duration,
};
use tantivy::{
    directory::MmapDirectory,
    doc,
    schema::{Field, Schema, FAST, STORED, TEXT},
    Index, IndexReader, IndexWriter, ReloadPolicy,
};
use tokio::sync::RwLock;

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub struct ClientServerMessage {
    /// Client address to send the response to.
    pub client_addr: Option<Recipient<ServerResponse>>,
    /// ID of the message, server will use this to send a response. Should be generated by the client.
    pub message_id: u128,
    /// Client's message.
    pub command: ClientCommand,
}

impl From<ClientCommand> for ClientServerMessage {
    fn from(cmd: ClientCommand) -> Self {
        Self {
            client_addr: None,
            message_id: 0,
            command: cmd,
        }
    }
}

#[derive(Clone)]
pub enum ClientCommand {
    Disconnect(Recipient<ServerMessage>),
    SubscribeHub(ID, ID, Recipient<ServerMessage>),
    UnsubscribeHub(ID, Recipient<ServerMessage>),
    SubscribeChannel(ID, ID, ID, Recipient<ServerMessage>),
    UnsubscribeChannel(ID, ID, Recipient<ServerMessage>),
    StartTyping(ID, ID, ID),
    StopTyping(ID, ID, ID),
    SendMessage(ID, ID, ID, String),
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub struct ServerResponse {
    /// ID of the message the server is responding to.
    pub responding_to: u128,
    /// Server's response.
    pub message: Response,
}

#[derive(MessageResponse, Clone, Display, FromStr, Message)]
#[rtype(result = "()")]
#[display(style = "SNAKE_CASE")]
pub enum Response {
    #[display("{}({0})")]
    Error(Error),
    Success,
    #[display("{}({0})")]
    Id(ID),
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub enum ServerMessage {
    NewMessage(ID, ID, channel::Message),
    HubUpdated(ID),
    TypingStart(ID, ID, ID),
    TypingStop(ID, ID, ID),
}

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub enum ServerNotification {
    NewMessage(ID, ID, channel::Message),
    HubUpdated(ID),
    Stop,
}

#[derive(Clone)]
struct MessageSchemaFields {
    content: Field,
    created: Field,
    id: Field,
    sender: Field,
}

pub struct Server {
    subscribed_channels: HashMap<(ID, ID), HashSet<Recipient<ServerMessage>>>,
    subscribed_hubs: HashMap<ID, HashSet<Recipient<ServerMessage>>>,
    subscribed: HashMap<Recipient<ServerMessage>, (HashSet<(ID, ID)>, HashSet<ID>)>,
    indexes:
        Arc<RwLock<HashMap<(ID, ID), Arc<(Index, Mutex<IndexWriter>, IndexReader, AtomicBool)>>>>,
    schema: Schema,
    schema_fields: MessageSchemaFields,
    tantivy_commit_rate: Duration,
}

impl Server {
    pub fn new(commit_rate: Duration) -> Self {
        let mut schema_builder = Schema::builder();
        schema_builder.add_text_field("content", TEXT);
        schema_builder.add_date_field("created", FAST);
        schema_builder.add_i64_field("id", STORED);
        schema_builder.add_i64_field("sender", FAST);
        let schema = schema_builder.build();
        Self {
            subscribed_channels: HashMap::new(),
            subscribed_hubs: HashMap::new(),
            subscribed: HashMap::new(),
            indexes: Arc::new(RwLock::new(HashMap::new())),
            schema: schema.clone(),
            tantivy_commit_rate: commit_rate,
            schema_fields: MessageSchemaFields {
                content: schema
                    .get_field("content")
                    .expect("Failed to create a Tantivy schema correctly."),
                created: schema
                    .get_field("created")
                    .expect("Failed to create a Tantivy schema correctly."),
                id: schema
                    .get_field("id")
                    .expect("Failed to create a Tantivy schema correctly."),
                sender: schema
                    .get_field("sender")
                    .expect("Failed to create a Tantivy schema correctly."),
            },
        }
    }

    fn get_index_arc(
        &mut self,
        hub_id: &ID,
        channel_id: &ID,
    ) -> Result<Arc<(Index, Mutex<IndexWriter>, IndexReader, AtomicBool)>> {
        let indexes = futures::executor::block_on(self.indexes.read());
        let index_arc = if let Some(get) = indexes.get(&(hub_id.clone(), channel_id.clone())) {
            get.clone()
        } else {
            drop(indexes);
            let dir_string = format!(
                "{}/{:x}/{:x}/index",
                crate::hub::HUB_DATA_FOLDER,
                hub_id.as_u128(),
                channel_id.as_u128()
            );
            let dir_path = std::path::Path::new(&dir_string);
            if !dir_path.is_dir() {
                std::fs::create_dir_all(dir_path)?;
            }
            let dir = MmapDirectory::open(dir_path).map_err(|_| DataError::Directory)?;
            let index = Index::open_or_create(dir, self.schema.clone())
                .map_err(|_| DataError::Directory)?;
            let reader = index
                .reader_builder()
                .reload_policy(ReloadPolicy::OnCommit)
                .try_into()
                .map_err(|_| DataError::Directory)?;
            let writer = index.writer(50_000_000).map_err(|_| DataError::Directory)?;
            let index_arc = Arc::new((index, Mutex::new(writer), reader, AtomicBool::new(false)));
            futures::executor::block_on(self.indexes.write())
                .insert((hub_id.clone(), channel_id.clone()), index_arc.clone());
            index_arc
        };
        Ok(index_arc)
    }

    async fn send_hub(
        subscribed_hubs: HashMap<ID, HashSet<Recipient<ServerMessage>>>,
        message: ServerMessage,
        hub_id: ID,
    ) {
        if let Some(subscribed) = subscribed_hubs.get(&hub_id) {
            for connection in subscribed {
                let _ = connection.do_send(message.clone());
            }
        }
    }

    async fn send_channel(
        subscribed_channels: HashMap<(ID, ID), HashSet<Recipient<ServerMessage>>>,
        message: ServerMessage,
        hub_id: ID,
        channel_id: ID,
    ) {
        if let Some(subscribed) = subscribed_channels.get(&(hub_id, channel_id)) {
            for connection in subscribed {
                let _ = connection.do_send(message.clone());
            }
        }
    }
}

impl Actor for Server {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        let interval = self.tantivy_commit_rate.clone();
        let indexes = self.indexes.clone();
        ctx.spawn(
            async move {
                loop {
                    tokio::time::delay_for(interval.clone()).await;
                    for index_arc in indexes.read().await.values() {
                        let arc = index_arc.clone();
                        if index_arc.3.load(Ordering::Relaxed) {
                            let mut writer = arc.1.lock().await;
                            if let Ok(_) = writer.prepare_commit() {
                                let _ = writer.commit();
                                index_arc.3.store(false, Ordering::Relaxed);
                            }
                        }
                    }
                }
            }
            .actfuture(),
        );
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> Running {
        let indexes = self.indexes.clone();
        ctx.wait(async move {
            for index_arc in indexes.read().await.values() {
                println!("Saving...");
                let arc = index_arc.clone();
                if index_arc.3.load(Ordering::Relaxed) {
                    let mut writer = arc.1.lock().await;
                    if let Ok(_) = writer.prepare_commit() {
                        let _ = writer.commit();
                    }
                }
            }
        }.actfuture());
        Running::Stop
    }
}

impl Handler<ClientServerMessage> for Server {
    type Result = ();

    fn handle(&mut self, msg: ClientServerMessage, ctx: &mut Self::Context) -> Self::Result {
        match msg.command.clone() {
            ClientCommand::Disconnect(addr) => {
                if let Some((channels, hubs)) = self.subscribed.get(&addr) {
                    for channel in channels {
                        self.subscribed_channels
                            .get_mut(channel)
                            .and_then(|s| Some(s.remove(&addr)));
                    }
                    for hub in hubs {
                        self.subscribed_hubs
                            .get_mut(hub)
                            .and_then(|s| Some(s.remove(&addr)));
                    }
                }
                self.subscribed.remove(&addr);
            }
            ClientCommand::SubscribeChannel(user_id, hub_id, channel_id, addr) => {
                futures::executor::block_on(async {
                    let result = Hub::load(&hub_id)
                        .await
                        .and_then(|hub| {
                            if let Ok(member) = hub.get_member(&user_id) {
                                Ok((hub, member))
                            } else {
                                Err(Error::MemberNotFound)
                            }
                        })
                        .and_then(|(hub, user)| {
                            if user.has_channel_permission(
                                &channel_id,
                                &crate::permission::ChannelPermission::ViewChannel,
                                &hub,
                            ) {
                                if user.has_channel_permission(
                                    &channel_id,
                                    &crate::permission::ChannelPermission::ReadMessage,
                                    &hub,
                                ) {
                                    self.subscribed
                                        .entry(addr.clone())
                                        .or_default()
                                        .0
                                        .insert((hub_id.clone(), channel_id.clone()));
                                    self.subscribed_channels
                                        .entry((hub_id, channel_id))
                                        .or_default()
                                        .insert(addr);
                                    Ok(())
                                } else {
                                    Err(Error::MissingChannelPermission(
                                        crate::permission::ChannelPermission::ReadMessage,
                                    ))
                                }
                            } else {
                                Err(Error::MissingChannelPermission(
                                    crate::permission::ChannelPermission::ViewChannel,
                                ))
                            }
                        });
                    let response = if let Err(error) = result {
                        Response::Error(error)
                    } else {
                        Response::Success
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: response,
                            })
                            .await;
                    }
                });
            }
            ClientCommand::UnsubscribeChannel(hub_id, channel_id, recipient) => {
                if let Some(subs) = self.subscribed.get_mut(&recipient) {
                    subs.0.remove(&(hub_id, channel_id));
                }
                if let Some(entry) = self.subscribed_channels.get_mut(&(hub_id, channel_id)) {
                    entry.remove(&recipient);
                }
            }
            ClientCommand::SubscribeHub(user_id, hub_id, addr) => {
                futures::executor::block_on(async {
                    let result = if let Err(error) = Hub::load(&hub_id)
                        .await
                        .and_then(|hub| hub.get_member(&user_id))
                    {
                        Response::Error(error)
                    } else {
                        self.subscribed
                            .entry(addr.clone())
                            .or_default()
                            .1
                            .insert(hub_id.clone());
                        self.subscribed_hubs.entry(hub_id).or_default().insert(addr);
                        Response::Success
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: result,
                            })
                            .await;
                    }
                });
            }
            ClientCommand::UnsubscribeHub(hub_id, recipient) => {
                if let Some(subs) = self.subscribed.get_mut(&recipient) {
                    subs.1.remove(&hub_id);
                }
                if let Some(entry) = self.subscribed_hubs.get_mut(&hub_id) {
                    entry.remove(&recipient);
                }
            }
            ClientCommand::StartTyping(user_id, hub_id, channel_id) => {
                let subscribed = self.subscribed_channels.clone();
                async move {
                    let result = if let Err(err) = {
                        let result = Hub::load(&hub_id)
                            .await
                            .and_then(|hub| hub.get_channel(&user_id, &channel_id).map(|_| ()))
                            .and_then(|_| {
                                Ok(Self::send_channel(
                                    subscribed,
                                    ServerMessage::TypingStart(hub_id, channel_id, user_id),
                                    hub_id,
                                    channel_id,
                                ))
                            });
                        if let Ok(fut) = result {
                            fut.await;
                            Ok(())
                        } else {
                            Err(result.err().unwrap())
                        }
                    } {
                        Response::Error(err)
                    } else {
                        Response::Success
                    };
                    if let Some(addr) = msg.client_addr {
                        let _ = addr
                            .send(ServerResponse {
                                responding_to: msg.message_id,
                                message: result,
                            })
                            .await;
                    }
                }
                .into_actor(self)
                .spawn(ctx);
            }
            ClientCommand::StopTyping(user_id, hub_id, channel_id) => {
                let subscribed = self.subscribed_channels.clone();
                Self::send_channel(
                    subscribed,
                    ServerMessage::TypingStop(hub_id, channel_id, user_id),
                    hub_id,
                    channel_id,
                )
                .into_actor(self)
                .spawn(ctx);
            }
            ClientCommand::SendMessage(user_id, hub_id, channel_id, message) => {
                let subscribed = self.subscribed_channels.clone();
                let MessageSchemaFields {
                    content,
                    created,
                    id,
                    sender,
                } = self.schema_fields.clone();
                if let Ok(index_arc) = self.get_index_arc(&hub_id, &channel_id) {
                    async move {
                        let res = {
                            let send =
                                api::send_message(&user_id, &hub_id, &channel_id, message).await;
                            if let Ok(message) = send {
                                let msg_id = message.id.clone();
                                tokio::spawn(async move {
                                    {
                                        let writer = index_arc.1.lock().await;
                                        writer.add_document(doc!(
                                            id => message.id.as_u128() as i64,
                                            sender => message.sender.as_u128() as i64,
                                            created => message.created.clone() as i64,
                                            content => message.content.clone(),
                                        ));
                                        index_arc.3.store(true, Ordering::Relaxed);
                                    }
                                    Self::send_channel(
                                        subscribed,
                                        ServerMessage::NewMessage(hub_id, channel_id, message),
                                        hub_id,
                                        channel_id,
                                    )
                                    .await;
                                });
                                Response::Id(msg_id)
                            } else {
                                Response::Error(send.err().unwrap())
                            }
                        };
                        if let Some(addr) = msg.client_addr {
                            let _ = addr
                                .send(ServerResponse {
                                    responding_to: msg.message_id,
                                    message: res,
                                })
                                .await;
                        }
                    }
                    .into_actor(self)
                    .spawn(ctx);
                }
            }
        }
    }
}

impl Handler<ServerNotification> for Server {
    type Result = ();

    fn handle(&mut self, msg: ServerNotification, ctx: &mut Self::Context) -> Self::Result {
        match msg {
            ServerNotification::NewMessage(hub_id, channel_id, message) => {
                let MessageSchemaFields {
                    content,
                    created,
                    id,
                    sender,
                } = self.schema_fields.clone();
                if let Ok(index_arc) = self.get_index_arc(&hub_id, &channel_id) {
                    let message = message.clone();
                    async move {
                        let writer = index_arc.1.lock().await;
                        writer.add_document(doc!(
                            id => message.id.as_u128() as i64,
                            sender => message.sender.as_u128() as i64,
                            created => message.created.clone() as i64,
                            content => message.content.clone(),
                        ));
                        index_arc.3.store(true, Ordering::Relaxed);
                    }
                    .into_actor(self)
                    .spawn(ctx);
                }
                Self::send_channel(
                    self.subscribed_channels.clone(),
                    ServerMessage::NewMessage(hub_id, channel_id, message),
                    hub_id,
                    channel_id,
                )
                .into_actor(self)
                .spawn(ctx);
            }
            ServerNotification::HubUpdated(hub_id) => {
                Self::send_hub(
                    self.subscribed_hubs.clone(),
                    ServerMessage::HubUpdated(hub_id),
                    hub_id,
                )
                .into_actor(self)
                .spawn(ctx);
            }
            ServerNotification::Stop => {
                ctx.stop();
            }
        }
    }
}
